# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QtZ928jZtj9KKWn9u84LEjrNBZR9sIP0
"""


import random
from collections import namedtuple

Image = namedtuple("Image", "id ori tagN tags")
Slide = namedtuple("Slide", "id1 id2 tagN tags")

def getImages(path):
  with open(path) as f:
    lines = f.readlines()
  print(len(lines))
  
  images = []
  lines = lines[1:]
  for i in range(len(lines)):
    images.append(getImage(i, lines[i]))
  return images

def getImage(index, line):
  row = line.strip().split(' ')
  return Image(index, row[0], row[1], row[2:])

def getSlides(images):
  print(f"totalimages {len(images)}")
  
  horizontalImages = [vimage for vimage in images if vimage.ori == 'H']
  horizontalSlides = [Slide(h.id, "", len(h.tags), h.tags) for h in horizontalImages]
  print(f"himages {len(horizontalSlides)}")
  
  verticalSlides = getBestVerticalPairs2(images)
  print(f"vimages {len(verticalSlides)}")

  slides = verticalSlides + horizontalSlides
  sortedList = sorted(slides, key=lambda x: x.tagN)
  sortedList.reverse()
  return sortedList
  
def getBestPair(image, images):
  bestScore = 999999
  bestImage = ""
  for cmpImage in images:
    tagsShared =  sum([int(cmpTag in image.tags) for cmpTag in cmpImage.tags])
    if tagsShared < bestScore:
      bestScore = tagsShared
      bestImage = cmpImage
  return bestImage

def getBestVerticalPairs(images):
  verticalImages = [vimage for vimage in images if vimage.ori == 'V']
  
  verticalPairs = []
  while len(verticalImages) > 0:
    img = verticalImages.pop(0)
    bestPair = getBestPair(img, verticalImages)
    verticalImages.remove(bestPair)
    verticalPairs.append([img, bestPair])
    
  return [Slide(pair[0].id, pair[1].id, len(set(pair[0].tags + pair[1].tags)), set(pair[0].tags + pair[1].tags)) for pair in verticalPairs]

def getBestVerticalPairs2(images):
  verticalImages = [vimage for vimage in images if vimage.ori == 'V']
  verticalImages = sorted(verticalImages, key=lambda x: x.tagN)
  
  verticalPairs = []
  while len(verticalImages) > 0:
    print("VImages len {0}".format(len(verticalImages)), end="\r")
    img = verticalImages.pop(0)
    bestPair = getBestPair(img, verticalImages[:1000])
    verticalImages.remove(bestPair)
    verticalPairs.append([img, bestPair])
  print("\n")
  return [Slide(pair[0].id, pair[1].id, len(set(pair[0].tags + pair[1].tags)), set(pair[0].tags + pair[1].tags)) for pair in verticalPairs]
  
def score_transition(slide1, slide2):
    common = len(list(set(slide1).intersection(slide2)))
    not_in_slide1 = len([x for x in slide1 if x not in slide2])
    not_in_slide2 = len([x for x in slide2 if x not in slide1])
    return min(common, not_in_slide1, not_in_slide2)

def print_output(slideShow, path):
  with open(path, "w") as f:
    f.write(f"{len(slideShow)}\n")
    for slide in slideShow:
      f.write(f"{slide.id1} {slide.id2}".strip())
      f.write("\n")

fileA = ["a_example.txt", "outputA.txt"]
fileB = ["b_lovely_landscapes.txt", "outputB.txt"]
fileC = ["c_memorable_moments.txt", "outputC.txt"]
fileD = ["d_pet_pictures.txt", "outputD.txt"]
fileE = ["e_shiny_selfies.txt", "outputE.txt"]
files = fileB

images = getImages(files[0])
slides = getSlides(images)

slideShow = []

sl = slides.pop(0)
slideShow.append(sl)

while len(slides) > 0:
  print("Slides len {0}".format(len(slides)), end="\r")

  compareBag = slides[:1000]
  
  bestSlide = ""
  bestScore = 0
  for cmp in compareBag:
    score = score_transition(sl.tags, cmp.tags)
    if score > bestScore:
      bestScore = score
      bestSlide = cmp
  
  if bestScore == 0:
    sl = slides.pop(0)
  else:
    slideShow.append(bestSlide)
    slides.remove(bestSlide)
    sl = bestSlide
print("\n")
print_output(slideShow, files[1])
